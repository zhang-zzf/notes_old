##  TODO

1. 多路归并
2. s=x+y算法及s=x+y+z等

## 循环不变式

需证明一下3点

1. 初始化，循环的第一次迭代之前，它为真
2. 如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真
3. 循环终止时，它为真

## 算法分析

预测算法需要的资源，通常是指时间度量，通过算法分析可以排除掉一些较差的实现。

## 算法设计

1. insertSort 属于增量排序
2. quickSort/mergeSort 属于分而治之排序

## Divide and Conquer

1. mergeSort 伪代码

   ```
   mergerSort(array, startIndex, endIndex) {
       if (startIndex < endIndex) {
           int mid = (startIndex + endIndex) / 2;
           mergeSort(array, startIndex, mid);
           mergeSort(array, mid + 1, endIndex)
           merge(array, startIndex, mid, endIndex);
       }
   }
   ```

2. mergeSort 最优和最坏的时间复杂度都是O(nlgn)

## 堆排序

#### 堆数据结构

A[1...n]

A.length 为数组长度

A.heap_size 为数组中堆大小

LEFT(i)：i的左孩子结点下标

RIGHT(i): i的右孩子结点下标

#### 维护堆

MAX_HEAPIFY 是用于维护最大堆的重要过程，它的输入为一个数组A和一个下标i，在调用MAX_HEAPIFY的时候，**我们假设根节点为LEFT(i)和RIGHT[i)的二叉树都是最大堆**。

**MAX_HEAPIFY 的时间复杂度为O(lgn)，也就是O(h)，h为堆的高度。**

##### MAX_HEAPIFY递归实现

```
MAX_HEAPIFY(A, i)
	l = LEFT(i)
	r = RIGHT(i)
	largest = i
	if existLeftChild
		if A[l] > A[largest]
			largest = l
		if existRightChild and A[r] > A[largest]
			largest = r
	if largest not equal i
		swap A[i] with A[largest]
		MAX_HEAPIFY(A, largest)
```

#####  MAX_HEAPIFY循环实现

```
MAX_HEAPIFY(A, i)
	while hasLeftChild(i)
		l = LEFT(i)
		r = RIGHT(i)
		largest = i
		if A[l] > A[largest]
			largest = l
		if hasRightChild(i) and A[r] > A[largest]
			largest = r
		if largest == i
			break
		else 
			swap A[i] with A[largest]
			i = largest
```

#### 建堆

我们可以利用自底向上的方法利用过程MAX_HEAPIFY把一个大小为n=A.length的数组A[1...n]转换为最大堆。由于n/2之后的元素都是叶子，只需对**n/2和之前**的元素调用MAX_HEAPIFY即可建立大堆。

**时间复杂度为O(nlgn)，更紧确的界是O(n)。**因此我们可以认为是在**线性时间内把无序数组构建成最大堆。**

#####BUILD_MAX_HEAP

```
BUILD_MAX_HEAP(A)
 for i=⌊n/2⌋ downto 1
 	MAX_HEAPIFY(A, i)
```

#### 插入法建堆

每次插入之前是一个大堆，MAX_HEAP_INSERT之后依然是一个大堆。

**循环不变式 A[1, i-1]是大堆，插入i元素到A中，A[1,i]是大堆。** 

##### MAX_HEAP_INSERT

```
MAX_HEAP_INSERT(A, x)
	A[++heap_size]=x
	for i=heap_size; i>1 and A[PARENT(i)]<x; i=PARENT(i) // 向上调整堆
		A[i]=A[PARENT(i)]
	A[i]=x
```

##### BUILD_MAX_HEAP_USE_INSERT

```
BUILD_MAX_HEAP_USE_INSERT(A)
	A.heap_size=0
	for x in A
		MAX_HEAP_INSERT(A,x)
```

#### 堆排序算法

调用BUILD_MAX_HEAP先把无序数组建立成大堆，A[1]便是数组中最大的元素。

i从n递减到1，每次交换A[1]和A[i]，把A.heap_size -=1然后MAX_HEAPIFY(A, 1)。

循环不变式：A[1...heap_size]依然是大堆（A[1] 依旧是A[1,heap_size]中的最大元素），A[i...n]是有序（A[i] ≤ A[i+1] ≤ ... ≤ A[n]）且A[i...n]为最终有序（A[n]为A[1...n]的最大值）

**时间复杂度为O(nlgn)**

#####HEAP_SORT

```
HEAP_SORT(A)
  BUILD_MAX_HEAP(A)
  for i=n downto 1
  	swap A[i] with A[1]
  	A.heap_size -= 1
  	MAX_HEAPIFY(A, 1)
```

## 优先队列（Priority Queue）

优先队列是一种维护由一组数据元素构成的集合S的数据结构，每个元素有一个权值，抽象数据结构如下

INSERT(S, x)：把x元素（k为其权值）插入到S中

MAXIMUM(S)：返回S集合中具有最大权值的元素

EXTRACT_MAX(S)：取出S集合中的最大权值的元素

MODIFY_KEY(S, x, k2)：增大或较小x元素的k值

##### 链式存储结构

> ?1：lastInsert无法移动到右边的相邻节点

```
Node {
  Node parent
  X x
  Node leftChild
  Node rightChild
}
```

```
PriorityQueue {
  Node header
  Node lastInsert
  int size
}
```

###### INSERT(S,x)

```
INSERT(S,x)
	Node nodex = Node(lastInsert, x, null, null)
	if lastIndex.leftChild == null
		lastIndex.leftChild = nodex
	else if lastIndex.rightChild == null
		lastIndex.rightChild = nodex
	else
```

##### 顺序存储结构

 ```
PriorityQueue {
  int length
  int heap_size
  X[] array
}
 ```

###### INSERT(S,x)

```
INSERT(S, x) 
	ensureCapacity()
	S[++heap_size] = x
	for (i = heap_size; i>=1 and S[i] > S[PARENT(i)]; i = PARENT(i)) 
		MAX_HEAPIFY(S, PARENT(i))
```

###### MAXIMUM(S)

```
MAXIMUM(S)
	return S[1]
```

###### EXTRACT_MAX(S)

```
EXTRACT_MAX(S)
	X ret = S[1]
	S[1] = S[heap_size]
	heap_size -= 1
	MAX_HEAPIFY(S, 0)
	return ret
```

###### MODIFY_KEY(S, x, k2)

```
MODIFY_KEY(S, x, k2)
	i = findXIndex(S, x)
	if (S[i].k > k2) // k值变小
		S[i].k = k2
		MAX_HEAPIFY(S, i) // 向下调整堆
	else if (S[i].k < k2) // k值变大
		S[i].k = k2
		for (j=i;j>=1 and S[j] > S[PARENT[j]];j=PARENT(j)) // 向上调整堆
			MAX_HEAPIFY(S, PARENT(j))
```

###### HEAP_DELETE

```
算法是错误的，不满足完全二叉树
HEAP_DELETE(S, i)
	l = LEFT(i)
	r = RIGHT(i)
	largest = i
	if l ≤ S.heap_size
		largest = l
		if r ≤ S.heap_size and S[r] > S[l]
			largest = r
	if laregest != i
		S[i] = S[largest]
		HEAP_DELETE(S, largest)
	else
		S.heap_size -= 1		
```

```
HEAP_DELETE(S, i)
	if (S[i] > S[heap_size]) // 向下调整堆
		S[i] = S[heap_size]
		MAX_HEAPIFY(S, i)	// lgn
	else if (S[i] < S[heap_size]) // 向上调整堆
		S[i] = S[heap_size]
		pivot = S[i]
		for (j=i; j>1 and S[PARENT(j)]<pivot; j=PARENT(j))
			S[j] = S[PARENT(j)]
		S[PARENT(j)] = pivot // very import
	S.heap_size -= 1
```









