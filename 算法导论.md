## TODO

1. 多路归并
2. s=x+y算法及s=x+y+z等

### 循环不变式

需证明一下3点

1. 初始化，循环的第一次迭代之前，它为真
2. 如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真
3. 循环终止时，它为真

### 算法分析

预测算法需要的资源，通常是指时间度量，通过算法分析可以排除掉一些较差的实现。

### 算法设计

1. insertSort 属于增量排序
2. quickSort/mergeSort 属于分而治之排序

### Divide and Conquer

1. mergeSort 伪代码

   ```
   mergerSort(array, startIndex, endIndex) {
       if (startIndex < endIndex) {
           int mid = (startIndex + endIndex) / 2;
           mergeSort(array, startIndex, mid);
           mergeSort(array, mid + 1, endIndex)
           merge(array, startIndex, mid, endIndex);
       }
   }
   ```

2. mergeSort 最优和最坏的时间复杂度都是O(nlgn)





## 基本数据结构

### 栈 stack

栈的数组实现S[1..n]，S.top指向栈顶元素，S.top=0时表示空栈，S.top=n时表示满栈。

#### STACK_EMPTY

```c++
STACK_EMPTY(S)
	if S.top=0
		return true
	return false
```

#### STACK_FULL

```c++
STACK_FULL(S)
	if S.top=n
		return true
	return false
```

#### PUSH

```c++
PUSH(S, x)
	if STACK_FULL(S)
		error "stack is full"
	S[++S.top]=x		
```

####POP

```c++
POP(S)
	if STACK_EMPTY(S)
		error "stack is empty"
	return S[S.top--]
```

### 队列 queue

循环队列的数组实现Q[1..n]，Q.size表示队列的大小（Q.size<=n），Q.head表示队列的头，Q.tail表示队列的尾

#### QUEUE_INIT

```
QUEUE_INIT(Q)
  Q.size=0
  Q.head=1
  Q.tail=1
```

#### EMPTY/FULL

```
QUEUE_EMPTY(Q)
	return Q.size==0

QUEUE_FULL(Q)
	return Q.size==n
```

#### ENQUEUE

```c++
ENQUEUE(Q, x)
	if QUEUE_FULL(Q)
		error "queue is full"
	Q[Q.tail]=x
	Q.size+=1
	Q.tail=(Q.tail+1)%n
```

####DEQUEUE

```c++
DEQUEUE(Q)
  if QUEUE_EMPTY(S)
    error "queue is empty"
	x=Q[Q.head]
	Q.size-=1
	Q.head=(Q.head+1)%n
	return x
```

Q[1..n]容纳n-1个元素时，只需要Q.head表示队列的头，Q.tail表示队列的尾

####  QUEUE_INIT

```
QUEUE_INIT(Q)
  Q.head=1
  Q.tail=1
```

#### EMPTY/FULL

```
QUEUE_EMPTY(Q)
	return Q.tail==Q.head

QUEUE_FULL(Q)
	return Q.tail+1==Q.head
```

#### ENQUEUE

```c++
ENQUEUE(Q, x)
	if QUEUE_FULL(Q)
		error "queue is full"
	Q[Q.tail]=x
	Q.tail=(Q.tail+1)%n
```

#### DEQUEUE

```c++
DEQUEUE(Q)
  if QUEUE_EMPTY(S)
    error "queue is empty"
	x=Q[Q.head]
	Q.head=(Q.head+1)%n
	return x
```

